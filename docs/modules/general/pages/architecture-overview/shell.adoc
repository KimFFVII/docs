= OneCX Shell

== Overview
OneCX Shell is the heart of the OneCX platform. It's an application that glues together all microfrontends and makes the platform seems like a single page application. Without the shell running, there will be nothing for users to use. Knowing this lets take a deeper look into what shell application consists of and its responsibilities.

== Application details

[[application_bundle]]
=== Application bundle
Below is a list of services that bundled are considered a shell application:

* UI - user interface application which renders the platform overlay and is responsible for routing between microfrontends and loading them
* Bff - backend service responsible for connecting with other core apps services to fetch the workspace and user data required for the UIs' platform construction

To work correctly, shell application requires many more services then listed above. In order to display correct content it cooperates with all of the core applications (via their services) and fetches the following data:

* Workspace information
** Base url of the workspace
** Name of workspace
** Routes to microfrontends within workspace
** Home page of workspace
** Display name of workspace
** Content style to apply within workspace
** Remote component definitions and assignments within the workspace
* User information
** User personal data
** Current user settings
*** Locale
*** Timezone
*** Color scheme
*** Menu display mode

// TODO: Add diagram of shell connections on the backend

=== Application responsibilities
In this section all responsibilities of shell application will be listed. We will be focusing on responsibilities of user interface since the bff responsibility is to make external calls. In the following sections we will refer to shells' user interface as shell.

==== User and workspace information loading
// TODO: Link to topics
On shell application start, external calls are made to fetch data mentioned in <<application_bundle, application bundle section>>. This data is then used to apply the theming for the application and pass down through topics, which are later used by the microfrontends and remote components. 

==== Preparation of valid routes within applications
// TODO: Link to webpack and module federation
When workspace data is fetched, shell application uses this information to construct routing rules accordingly to the workspace configuration. For each route defined for a workspace it creates a routing rule that results in loading desired microfrontend whenever the route is selected.

Lets make an example:

* Assumptions
** All core applications are registered in the workspace
** Workspace is called `my-workspace`
** User Profile application is configured to be available via `/user` url
** Shell application is running on localhost 4300 port with no suffix.
* Scenario
** When user enters `localhost:4300/my-workspace/chosen-url`, shell aplication will try to load information related to `my-workspace` and authenticated user
** Then it will create application routes
** When routes creation process is finalized, shell application will proceed with the routing and try to find a route matching `chosen-url`
** In case `chosen-url` is `user`, shell will load User Profile microfrontend and display it in the content section of the page

__NOTE__: Module loading mechanism is done by external package via webpack and module federation solutions. 

==== Routing consistency
Every microfrontend can have its own router with, however shells' router is reacting to routing changes propagated by microfrontend routers. Depending on the used technology for microfrontend exposal (microfrontend can be exposed as an Angular module or Webcomponent), the router behavior differents, however the results should not differ and routing should feel similar to a single page application experience.
