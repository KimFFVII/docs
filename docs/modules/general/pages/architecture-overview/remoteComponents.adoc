= OneCX Remote Components

== Overview
If you are familiar with webpack and module federation with Angular, you might think that OneCX remote components are the same thing as microfrontend, but the difference is that instead of exposing a module remote components expose components. When that statement is true, OneCX remote components are much more than that.

== Remote components concept
When discussing remote components there are couple of important concepts that need explanation in order to fully get the point of remote components.

=== Remote component definition
Remote component is a small piece of user interface that is associated with an application and can be used by other applications. It can be a simple component like button or more complex one like a data table. It is up to you to determine what content should such component represent and it can vary depending on the needs.

As an example, we can create remote component in user management application representing a button which will open dialog to change user password on click. This remote component will then still be defined in context of user application, but will be usable in any desired microfrontend. With this example User application bundle would be the following:

* UI - permssion management user interface microfrontend
* User Bff - backend service to make calls to other services
* User SVC - backed service to manage permissions
* Change Password Component - remote component used in other apps to change user password

=== OneCX Slot
Every remote component requires a host to be displayed within a page. OneCX slots are the elements fulfilling this role. If you want to use an existig remote component or you suspect you will need to use one in your microfrontend, you should use the OneCX Slot for it.

==== Slot definition
Slot is a standard component to use in your html content template. It uses workspace information located in one of the topics (that information is published by shell application) to determine what content should be loaded inside it. This gives us the possibility to dynamically assign content to slots and modify the application without needing to restart the application.

=== Slot mechanism
When you use a slot it needs the following requirements to be fullfield: 

* have a unique name
* be assigned to a workspace

__NOTE__: You can configure slots using workspace application.

If those conditions are met and your workspace has slot assigned to it, these are things you need to do to use it: 

* use a slot component in your content (microfrontend or remote component)
* make sure it has a name equal to the one set in the workspace
* assign 

You can use slot components anywhere in the application. It is even allowed to use slots inside remote components, so you could possibly create a chain of slots (slot loading component wiht slot, ...)

== Remote component registration
Remote components just like microfrontends are regular frontend applications that are exposed to the world using webpack. The only difference is that remote component represents a single piece of user interface where microfrontends are meant for complete application interfaces.

// TODO: Instead of explaining what to do, add a link to documentation page that does that and explain only what happens when you register component/slot

// TODO: Explain what to do to correctly register remote component and what happens when you do that

== Slot registration
// TODO: Explain what to do to correctly register slot and what happens when you do that

== Slot usage
// TODO: Explain what to do to correctly use slot and what happens when you do that

== Remote components example using Angular
