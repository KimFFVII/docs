= OneCX Microfrontend content bootstrapping

== Overview
// TODO: Add link to MFE loading
This document aims to explain the details related to Microfrontend's content bootstrapping. Depending on the content's type and expose method there are different requirements needed to be fullfield to ensure the content is loaded correctly by OneCX platform elements. This topic is highly related to Microfrontend content loading and xref:webpack.adoc[Microfrontend configuration with Webpack]. It is recommended to be familiar with those before reading this document.

== Microfrontend's content bootstrapping explained
// TODO: Add link to MFE loading
Microfrontend's content loading is an action triggered by the route change (Shell Application's responsibility of loading modules) or by the Slot Component display (Slot Component's responsibility of loading Remote Components). During this action Microfrontend's content, exposed via remote entry file, is loaded and bootstrapped using provided file in xref:webpack.adoc[Webpack configuration].

Depending on the content type and chosen expose method, different adjustments have to be made to ensure correct content bootstrapping. 

=== Content exposed using Angular method
IMPORTANT: **It is NOT recommended** to use Angular expose method. Doing so restraints the platform from using many frameworks with different versions, which means that all Microfrontends would need to use the same technology and version.

When exposing modules and Remote Components using Angular method, there are two requirements.

. Webpack configuration needs to expose the module or component file directly. It means that instead of pointing to a **main.ts** file that is bootstrapping the content, **module.ts** and **component.ts** files should be used directly.
. **main.ts** file of Microfrontend's modules (content type) need to bootstrap the module asynchronously.
+
**main.ts** content should look similar to:
[source,typescript]
import('./bootstrap').catch(err => console.error(err));
+
**bootstrap.ts** content should look similar to (or any custom bootstrap of your Microfrontend):
+
[source,typescript]
....
import { AppModule } from './app/app.module';
import { environment } from './environments/environment';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { enableProdMode } from '@angular/core';

if (environment.production) {
  enableProdMode();
}

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));
....

=== Content exposed using Webcomponent method
// TODO: Correct link to exact resource for @onecx/angular-webcomponents lib
xref:implementation-details/mfe-content-loading/webcomponents.adoc[Loading mechanism for modules and Remote Components exposed using Webcomponent method] requires that content is adapted to using Web Components Custom Elements. For both content types, bootstrapping logic needs to register Custom Element in the Custom Elements Registry.

// TODO: Correct link to exact resource for Angular issues
NOTE: For Angular based content, apart from Custom Element registration it is also required to cover few Angular related issues. For more information on those issues, please refer xref:implementation-details/mfe-content-loading/webcomponents.adoc[here]

// TODO: Correct link to exact resource for @onecx/angular-webcomponents lib
It is recommended to use xref:implementation-details/mfe-content-loading/webcomponents.adoc[@onecx/angular-webcomponents] library to bootstrap Microfrontend's content using its exposed methods. This library will be used in the examples throughout this document.

==== Module bootstrapping and configuration
The following requirements need to be fullfield when exposing modules using Webcomponent method:

. Webpack configuration need to expose the *main.ts* file of the module.
. **main.ts** file of the module needs to bootstrap the module asynchronously.
// TODO: Correct link to exact resource for Angular issues
. Module bootstrap has to cover Angular issues (for Angular based modules only)
. Module class
.. needs to register an entrypoint as Custom Element in Custom Elements Registry.
.. needs to adapt routing so Shell registers routing happening within the module.
.. needs to adapt configuration so services are using correct urls to external resources.

Below, a module setup example (Angular based) for using Webcomponent expose method is presented. Each file's content is going to be explained in details with important context information for other technologies than presented.

.webpack.config.js
[source, typescript]
....
const config = withModuleFederationPlugin({
  name: 'example-ui',
  filename: 'remoteEntry.js',
  exposes: {
    './ExampleModule': './src/main.ts'
  },
  ...
})
....

Webpack configuration is exposing a **main.ts** file.

.src/main.ts
[source, typescript]
....
import('./bootstrap').catch((err) => console.error(err))
....

**main.ts** file is importing (asynchronously) **bootstrap.ts** file.

.src/bootstrap.ts
[source, typescript]
....
import { bootstrapModule } from '@onecx/angular-webcomponents'
import { environment } from './environments/environment'
import { ExampleModule } from './app/module'

bootstrapModule(ExampleModule, 'microfrontend', environment.production)
....

// TODO: Correct link to exact resource for Angular issues
**bootstrap.ts** file is bootstrapping the module using @onecx/angular-webcomponents library to ensure that Angular ngZone and platform are shared (Angular requirement only). For other technologies, simply call any asynchronous bootstrap function required.

.src/app/module.ts
[source, typescript]
....
import { HttpClient, provideHttpClient, withInterceptorsFromDi } from '@angular/common/http'
import { APP_INITIALIZER, DoBootstrap, Injector, NgModule } from '@angular/core'
import { Router, RouterModule, Routes } from '@angular/router'
import { BrowserModule } from '@angular/platform-browser'
import { BrowserAnimationsModule } from '@angular/platform-browser/animations'
import { CommonModule } from '@angular/common'
import { MissingTranslationHandler, TranslateLoader, TranslateModule } from '@ngx-translate/core'
import {
  AppStateService,
  ConfigurationService,
  createTranslateLoader,
  PortalCoreModule,
  PortalMissingTranslationHandler,
  PortalApiConfiguration,
} from '@onecx/portal-integration-angular'
import { AngularAuthModule } from '@onecx/angular-auth'
import { createAppEntrypoint, initializeRouter, startsWith } from '@onecx/angular-webcomponents'
import { addInitializeModuleGuard } from '@onecx/angular-integration-interface'
import { Configuration } from './shared/generated'

@Component({
  selector: 'app-root',
  template: `<router-outlet></router-outlet>`
})
export class AppEntrypointComponent {}

export const routes: Routes = [
  {
    matcher: startsWith(''),
    loadChildren: () => import('./feature/feature.module').then((mod) => mod.FeatureModule)
  },
  {
    matcher: startsWith('tracking'),
    loadChildren: () => import('./tracking/tracking.module').then((mod) => mod.TrackingModule)
  }
]

function apiConfigProvider(configService: ConfigurationService, appStateService: AppStateService) {
  return new PortalApiConfiguration(Configuration, environment.apiPrefix, configService, appStateService)
}

@NgModule({
    declarations: [AppEntrypointComponent],
    imports: [
        CommonModule,
        PortalCoreModule.forMicroFrontend(),
        RouterModule.forRoot(addInitializeModuleGuard(routes)),
        TranslateModule.forRoot({
        extend: true,
        isolate: false,
        loader: {
            provide: TranslateLoader,
            useFactory: createTranslateLoader,
            deps: [HttpClient, AppStateService]
        },
        missingTranslationHandler: {
            provide: MissingTranslationHandler,
            useClass: PortalMissingTranslationHandler
        }
        }),
        BrowserModule,
        AngularAuthModule,
        BrowserAnimationsModule,
    ],
    exports: [],
    providers: [
        {
            provide: Configuration,
            useFactory: apiConfigProvider,
            deps: [ConfigurationService, AppStateService]
        },
        {
            provide: APP_INITIALIZER,
            useFactory: initializeRouter,
            multi: true,
            deps: [Router, AppStateService]
        },
        provideHttpClient(withInterceptorsFromDi())
    ]
})
export class ExampleModule implements DoBootstrap {
    constructor(private readonly injector: Injector) {}

    ngDoBootstrap(): void {
        createAppEntrypoint(AppEntrypointComponent, 'example-component', this.injector)
    }
}
....

**module.ts** file is prepares the module for integration with OneCX platform.

This example showcases the recommended approach of defining modules (Angular based) using Webcomponent method. Here is a list of important features of this example:

Module imports:: 
* CommonModule, BrowserModule and BrowserAnimationsModule Angular modules used for adding functionality to the module.
* PortalCoreModule is defined to allow usage of OneCX components and services.
* TranslateModule is defined to allow translations using translation keys within the module.
// TODO: Add link to auth docs
* AngularAuthModule is defined to use OneCX authorization mechanisms.
* RouterModule is defined for routing to feature modules within the exposed module.

Entrypoint component::
// TODO: Add link to createAppEntrypoint
AppEntrypoint is a standard Angular component, which has a `<router-outlet>` element in its template. The `createAppEntrypoint` registers AppEntrypointComponent in Custom Elements Registry, so anytime '<example-component>' is rendered, AppEntypointComponent should be instantiated.
+
The third parameter, being the module's Injector, is very important. This injector will be used by the instances of AppEntrypointComponent rendered using Web Components technology, meaning that each instance will have everything related to the module already set up. That also means the `<router-outlet>` will be using routes defined for the module.
+
// TODO: Add link to createAppEntrypoint
// TODO: Link to events topic
[[module-rotuer-connection]]The `createAppEntrypoint` method is also responsible for connecting module's router to Shell's router. Everytime the url of the browser changes, Shell is going to publish a new message, via EventsTopic, with information about new url. The `createAppEntrypoint` method subscribes to the EventsTopic and updates the router state accordingly to the received information.
+
For other technologies then Angular it is recommended to:
+
--
* register Custom Element in Custom Elements Registry.
* provide dependencies to registered Custom Element accordingly to the module.
* listen to EventsTopic data changes and update the state of module's routing.
--

Routes matching::
Each route defined will load a feature module whenever it is activated. Beacuse Webcomponent expose method causes multiple routers to exist at the same time (Shell has its own router and every module or Remote Component displayed at a single point of time can have their own), an adjustment to the routes definition has to be made.
+
The idea of routing in this example is the following:
+
--
* User enters 'shell_url/workspace_name/example_base_path' url - FeatureModule is used.
* User enters 'shell_url/workspace_name/example_base_path/tracking' url - TrakcingModule is used.
--
+
With the following url parts meaning:
+
--
* shell_url - the Shell Application deployment url, e.g. `localhost:4200/shell.`
* workspace_name - name of the accessed Workspace, e.g. `admin`.
* example_base_path - base path of the example Microfrontend (configured via OneCX Core Applications), e.g. `example`.
--
+
Prior to routing within Microfrontend's module, Shell uses shell_url, workspace_name and example_base_path parts of the url to load the module. Because of this fact, module's router needs to remove those parts from consideration when matching its routes. Usually, `path` property of route is used to control the route activation, but in that case Microfrontend's module needs a way to only match the relevant part of the url.
+
// TODO: Add link to @onecx/angular-webcomponents functions
// TODO: Add link to startsWith
// TODO: Add link to initializeRouter
Using `startsWith` function from `@onecx/angular-webcomponents`, for https://angular.dev/api/router/UrlMatcher[matcher] property of a route object, results in router considering only those url parts relevant to the module. In order for it to work properly, the `initializeRouter` provider has to be added for the module as an app initializer.
+
During module creation `initializeRouter`:
+
--
// TODO: Link to Topic
* adds Microfrontend information (based on CurrentMfeTopic) to each route.
* rewrites routes containing `redirectTo` for correct redirection.
* creates new route (used when routing away from the module):
** matched when none of the defined routes was matched.
** displays nothing (for a period of time when user routes between Microfrontends).
--
+
// TODO: link to statsWith
The `startsWith` method uses Microfrontend information, saved in route's data, to remove already used parts from consideration when matching routes within the module.
+
// TODO: link to lib
To create your own matchers, please consider using `@onecx/angular-webcomponents` library.
+
For other technologies then Angular it is recommended to:
+
--
* Use Microfrontend information from CurrentMfeTopic to only use relevent parts of the url for routing and redirect correctly.
* Ensure routing away from the module is not causing side-effects.
--

Configuration::
All services utilizing HttpClient used within the Microfrontend's module need to know how to make requests to external resources. Depending on the configuration of Workspace, they need to take that context into consideration when creating url for those resources.
+
A service might want to call `deployment_url/bff/search` by default. With this call being made, MFE App will need to access the BFF. When Application's path within the Workspace is `mfe/example` the call has to be made to `deployment_url/mfe/example/bff/search`.
+
// TODO: Link to Topic
The `apiConfigProvider` presented in the example is utilizing `PortalApiConfiguration` class as `Configuration` for the services. It is listening to the CurrentMfeTopic changes and overwriting the basePath accordingly to the received message and all services use that information to construct a valid url.
+
For other technologies then Angular it is recommended to:
+
--
* Listen to CurrentMfeTopic changes and overwrite services configuration to ensure correct resource is accessed.
--

==== Remote Component bootstrapping and configuration
The following requirements need to be fullfield when exposing Remote Components using Webcomponent method:

. Webpack configuration need to expose the *main.ts* file of the Remote Component.
. **main.ts** file of the Remote Component needs to bootstrap the component asynchronously.
// TODO: Correct link to exact resource for Angular issues
. Component bootstrap
.. has to cover Angular issues (for Angular based Remote Components only)
.. needs to register the component as Custom Element in Custom Elements Registry.
.. needs to adapt routing so Shell registers routing happening within the Remote Component.
. Component class needs to use Remote Component initialization mechanism.

Below, a Remote Component setup example (Angular based) for using Webcomponent expose method is presented. Each file's content is going to be explained in details with important context information for other technologies then presented.

.webpack.config.js
[source, typescript]
....
const config = withModuleFederationPlugin({
  name: 'example-ui',
  filename: 'remoteEntry.js',
  exposes: {
    './ExampleComponent': './src/app/remotes/example/example.component.main.ts'
  },
  ...
})
....

Webpack configuration is exposing a **example.component.main.ts** file.

.src/app/remotes/example/example.component.main.ts
[source, typescript]
....
import('./example.component.bootstrap').catch((err) => console.error(err))
....

**example.component.main.ts** file is importing (asynchronously) **example.component.bootstrap.ts** file.

.src/app/remotes/example/example.component.bootstrap.ts
[source, typescript]
....
import {
  HttpClient,
  provideHttpClient,
  withInterceptorsFromDi,
} from '@angular/common/http';
import {
  APP_INITIALIZER,
  importProvidersFrom
} from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';
import { AngularAuthModule } from '@onecx/angular-auth';
import { bootstrapRemoteComponent } from '@onecx/angular-webcomponents';
import {
  createRemoteComponentTranslateLoader,
  UserService
} from '@onecx/portal-integration-angular';
import { environment } from 'src/environments/environment';
import { ExampleComponent } from './example.component';
import {
  BASE_URL,
  provideTranslateServiceForRoot,
} from '@onecx/angular-remote-components';
import { TranslateLoader } from '@ngx-translate/core';
import { ReplaySubject } from 'rxjs';

function userProfileInitializer(userService: UserService) {
  return async () => {
    await userService.isInitialized;
  };
}

bootstrapRemoteComponent(
  ExampleComponent,
  'example-remote-component',
  environment.production,
  [
    provideHttpClient(withInterceptorsFromDi()),
    {
      provide: BASE_URL,
      useValue: new ReplaySubject<string>(1),
    },
    provideTranslateServiceForRoot({
      isolate: true,
      loader: {
        provide: TranslateLoader,
        useFactory: createRemoteComponentTranslateLoader,
        deps: [HttpClient, BASE_URL],
      },
    }),
    importProvidersFrom(
      AngularAuthModule,
      BrowserModule,
      BrowserAnimationsModule,
    ),
    {
      provide: APP_INITIALIZER,
      useFactory: userProfileInitializer,
      deps: [UserService],
      multi: true,
    },
  ]
)
....

// TODO: Correct link to exact resource for Angular issues
// TODO: Link to the @onecx/angular-webcomponents
**example.component.bootstrap.ts** file is bootstrapping the Remote Component using @onecx/angular-webcomponents library to ensure that Angular ngZone and platform are shared (Angular requirement only). It also connects Shell router with the Remote Component's router (if such exists). The last argument is an array of providers required for component to work properly. Detailed description of this file can be found in the <<summary>>.

.src/app/remotes/example/example.component.ts
[source, typescript]
....
import { CommonModule, Location } from '@angular/common';
import { Component, Inject, Input } from '@angular/core';
import { TranslateModule, TranslateService } from '@ngx-translate/core';
import { AngularAuthModule } from '@onecx/angular-auth';
import {
  UserService
} from '@onecx/angular-integration-interface';
import {
  AngularRemoteComponentsModule,
  BASE_URL,
  ocxRemoteComponent,
  ocxRemoteWebcomponent,
  RemoteComponentConfig,
} from '@onecx/angular-remote-components';
import {
  PortalCoreModule
} from '@onecx/portal-integration-angular';
import { ReplaySubject } from 'rxjs';
import { environment } from 'src/environments/environment'

@NgModule({
  imports: [
    PortalCoreModule.forMicroFrontend()
  ]
})
export class SharedModule {}

@Component({
  standalone: true,
  imports: [
    AngularAuthModule,
    AngularRemoteComponentsModule,
    CommonModule,
    SharedModule,
    PortalCoreModule,
    TranslateModule,
  ],
  selector: 'example-comp',
  template: `<h>Hello from Remote Component</h>`,
})
export class ExampleComponent
  implements ocxRemoteComponent, ocxRemoteWebcomponent
{
  permissions: string[] = [];

  constructor(
    @Inject(BASE_URL) private readonly baseUrl: ReplaySubject<string>,
    private readonly userService: UserService,
    private readonly translateService: TranslateService,
    private readonly exampleService: ExampleAPIService
  ) {
    this.translateService.use(this.userService.lang$.getValue());
  }

  @Input() set ocxRemoteComponentConfig(config: RemoteComponentConfig) {
    this.ocxInitRemoteComponent(config);
  }

  ocxInitRemoteComponent(config: RemoteComponentConfig): void {
    this.baseUrl.next(config.baseUrl);
    this.permissions = config.permissions;
    this.exampleService.configuration = new Configuration({
      basePath: Location.joinWithSlash(config.baseUrl, environment.apiPrefix)
    })
  }
}
....

**example.component.ts** file prepares the Remote Component for integration with OneCX platform.

[[summary]]This example showcases the recommended approach of defining Remote Components (Angular based) using Webcomponent method. Here is a list of important features of this example:

Component bootstrap::
Remote Components are better suited for integration with the Web Components Custom Elements concept. The biggest reason for it is that a Remote Component already represents a component, meaning that there is no need to define any additional entrypoint component (like it was done for module content type).
+
// TODO: Link to bootstrapRemoteComponent
The `bootstrapRemoteComponent` method is bootstrapping the Remote Component. It is responsible for:
+
Creating application:::
// TODO: Link to bootstrapRemoteComponent
As a first step `bootstrapRemoteComponent` method is going to create Angular application. Created application will use defined providers (argument of `bootstrapRemoteComponent`). In this example, the following providers are defined:
+
--
* HttpClient  (via provideHttpClient) - used for making HTTP calls.
* TranslateService (via provideTranslateServiceForRoot) - used for making translations via translation keys.
* providers from AngularAuthModule - OneCX authorization mechanisms.
* providers from BrowserModule.
* providers from BrowserAnimationsModule.
// TODO: Link to userService
* APP_INITIALIZER using userProfileInitializer factory function - in ExampleComponent's constructor `this.userService.lang$.getValue()` call is made to set TranslationService language. Since that call is synchronous, it is important to ensure that UserService has been initialized before fetching its data.
--
+
// TODO: Link to bootstrapRemoteComponent
IMPORTANT: Providers passed in `bootstrapRemoteComponent` method call should contain any providers required by the Remote Component. Any services or injection tokens have to be defined here. It is important that those providers are aligned with imports defined via Remote Component's definition. Depending on the Remote Component different providers and imports will be defined.

+
Created application is going to have an Injector (just like a module does). This Injector will be used by the instance of ExampleComponent rendered using Web Components technology.
+
// TODO: Link to bootstrapRemoteComponent
For Angular based Remote Components it is recommended to use `bootstrapRemoteComponent` and define every required provider as an argument of this method. This approach will ensure that rendered component has all required services, tokens, etc. already set up.
// TODO: Correct link to exact resource for Angular issues
// TODO: Link to bootstrapRemoteComponent
Fixing Angular issues (Angular requirement only):::
The `bootstrapRemoteComponent` method takes care of ngZone and platform sharing.
Connecting router:::
// TODO: Link to bootstrapRemoteComponent
The `bootstrapRemoteComponent` method is responsible for connecting Remote Component's router to Shell's router (if there is one defined), so their states are always the same. The connection is set up in the same way as for <<module-rotuer-connection, module's router>>.
Registering the Custom Element:::
// TODO: Link to bootstrapRemoteComponent
The `bootstrapRemoteComponent` method registers ExampleComponent in Custom Elements Registry, so anytime `<example-remote-component>` is rendered, ExampleComponent should be instantiated.

+
For other technologies then Angular it is recommended to:
* register Custom Element in Custom Elements Registry.
* provide dependencies to registered Custom Element accordingly to the Remote Component.
* listen to EventsTopic data changes and update the state of Remote Component's routing (if routing is used).

Component definition and configuration::
For Angular based components, any Remote Component is required to be a standalone Angular component. The component's import array's purpose is to declare all required dependencies just like for Angular modules. It is recommended to import:
+
--
* AngularAuthModule for authorization mechanisms.
* CommonModule for common Angular funtionalities.
* SharedModule with `PortalCoreModule.forMicroFrontend()` import for allowing OneCX components and services usage.
* PortalCoreModule so component recognizes OneCX components and services.
* TranslateModule for translations mechanism.
* AngularRemoteComponentsModule.
--
+
// TODO: Link to bootstrapRemoteComponent
In the **example.component.bootstrap.ts** some providers related to those dependencies were already declared in `bootstrapRemoteComponent` method call.

+
For other technologies then Angular it is recommended to:

* define the component so that all dependencies are provided.

Configuration and initialization::
ExampleComponent implements two interfaces:
+
--
* ocxRemoteComponent - requires component to define ocxInitRemoteComponent method
* ocxRemoteWebcomponent - requires component to define ocxRemoteComponentConfig property
--
+
// TODO: Link to slot component
For Webcomponent method it is required to implement ocxRemoteWebcomponent, but optional to implement ocxRemoteComponent. The `ocxRemoteComponentConfig` is set by the Remote Component's Slot Component after Remote Component's element is created in the html. The value that is set is of type <<RemoteComponentConfig>>. On receiving the configuration, Remote Component should:
+
--
* update BASE_URL.
* update permissions (if permissions are used).
* update base url of its services (if services that require external calls are used).
--
+
[[RemoteComponentConfig]]
.RemoteComponentConfig structure
|===
|**Property**|**Type**|**Description**
|`appId` | `string` | Unique identifier of the Microfrontend Remote Component is part of.
|`productName` | `string` | Name of the Application currently Remote Component is part of.
|`permissions` | `string[]` | Current user permissions related to the Remote Component's Microfrontend.
|`baseUrl` | `string` | Url of Remote Component's Microfrontend to be used when accessing its content (remote entry file, assets, etc.), e.g. `'/mfe/mfe_name'`.
|===
+
For other technologies then Angular it is recommended to:

* implement the component so ocxRemoteComponentConfig property is defined and whenever it is set:
** the component's resources or the component itself will use the correct baseUrl to access external resources.
** permission checking mechanisms will use provided permissions
